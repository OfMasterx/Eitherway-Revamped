/**
 * Contract Code Generator
 *
 * Generates TypeScript/React code for deployed smart contracts:
 * - ABI files (contract-name.abi.ts)
 * - Address files (contract-name.addresses.ts)
 * - Wagmi hooks (useContractName.ts)
 * - React components (ContractNamePanel.tsx)
 */

import type { DatabaseClient } from '../client.js';
import { ContractsRepository } from '../repositories/contracts.js';

export interface GeneratedContractFiles {
  abiFile: {
    filename: string;
    content: string;
  };
  addressesFile: {
    filename: string;
    content: string;
  };
  hooksFile: {
    filename: string;
    content: string;
  };
  componentFile: {
    filename: string;
    content: string;
  };
  wagmiConfigFile: {
    filename: string;
    content: string;
  };
}

export interface ContractInfo {
  id: string;
  name: string;
  contractType: string;
  abi: any[];
  deployedAddress: string;
  deployedChainId: number;
  symbol?: string;
}

export class ContractCodeGenerator {
  private contractsRepo: ContractsRepository;

  constructor(db: DatabaseClient) {
    this.contractsRepo = new ContractsRepository(db);
  }

  /**
   * Generate all code files for a deployed contract
   */
  async generateContractFiles(contractId: string): Promise<GeneratedContractFiles> {
    // Get contract from database
    const contract = await this.contractsRepo.findById(contractId);

    if (!contract) {
      throw new Error(`Contract not found: ${contractId}`);
    }

    if (!contract.deployed_address || !contract.abi) {
      throw new Error('Contract must be deployed and have ABI to generate code');
    }

    const contractInfo: ContractInfo = {
      id: contract.id,
      name: contract.name,
      contractType: contract.contract_type,
      abi: contract.abi as any[],
      deployedAddress: contract.deployed_address,
      deployedChainId: contract.deployed_chain_id!,
      symbol: contract.symbol || undefined
    };

    // Generate files
    const abiFile = this.generateABIFile(contractInfo);
    const addressesFile = this.generateAddressesFile(contractInfo);
    const hooksFile = this.generateHooksFile(contractInfo);
    const componentFile = this.generateComponentFile(contractInfo);
    const wagmiConfigFile = this.generateWagmiConfigFile();

    return {
      abiFile,
      addressesFile,
      hooksFile,
      componentFile,
      wagmiConfigFile
    };
  }

  /**
   * Generate multiple contracts at once (for apps with multiple contracts)
   */
  async generateMultipleContracts(contractIds: string[]): Promise<Record<string, GeneratedContractFiles>> {
    const results: Record<string, GeneratedContractFiles> = {};

    for (const contractId of contractIds) {
      const files = await this.generateContractFiles(contractId);
      results[contractId] = files;
    }

    return results;
  }

  /**
   * Generate ABI file
   * Example: MyToken.abi.ts
   */
  private generateABIFile(contract: ContractInfo): { filename: string; content: string } {
    const contractName = this.toPascalCase(contract.name);
    const filename = `${contractName}.abi.ts`;

    const content = `/**
 * ${contract.name} - Contract ABI
 * Type: ${contract.contractType.toUpperCase()}
 * Chain ID: ${contract.deployedChainId}
 *
 * Auto-generated by EitherWay
 */

export const ${contractName}ABI = ${JSON.stringify(contract.abi, null, 2)} as const;

export type ${contractName}ABI = typeof ${contractName}ABI;
`;

    return { filename, content };
  }

  /**
   * Generate addresses file (supports multi-chain)
   * Example: MyToken.addresses.ts
   */
  private generateAddressesFile(contract: ContractInfo): { filename: string; content: string } {
    const contractName = this.toPascalCase(contract.name);
    const filename = `${contractName}.addresses.ts`;

    const chainNames: Record<number, string> = {
      1: 'mainnet',
      11155111: 'sepolia',
      84532: 'baseSepolia',
      421614: 'arbitrumSepolia'
    };

    const chainName = chainNames[contract.deployedChainId] || `chain${contract.deployedChainId}`;

    const content = `/**
 * ${contract.name} - Contract Addresses
 * Type: ${contract.contractType.toUpperCase()}
 *
 * Auto-generated by EitherWay
 */

export const ${contractName}Addresses = {
  ${chainName}: '${contract.deployedAddress}' as const,
} as const;

export type ${contractName}Addresses = typeof ${contractName}Addresses;

// Default chain ID: ${contract.deployedChainId}
export const DEFAULT_${contractName.toUpperCase()}_CHAIN_ID = ${contract.deployedChainId};
`;

    return { filename, content };
  }

  /**
   * Generate Wagmi hooks file
   * Example: useMyToken.ts
   */
  private generateHooksFile(contract: ContractInfo): { filename: string; content: string } {
    const contractName = this.toPascalCase(contract.name);
    const filename = `use${contractName}.ts`;

    // Extract read and write functions from ABI
    // const readFunctions = contract.abi.filter(
    //   (item: any) => item.type === 'function' && (item.stateMutability === 'view' || item.stateMutability === 'pure')
    // );

    // const writeFunctions = contract.abi.filter(
    //   (item: any) => item.type === 'function' && item.stateMutability !== 'view' && item.stateMutability !== 'pure'
    // );

    // Generate hook examples for common functions
    let hookExamples = '';

    // For ERC-20 tokens
    if (contract.contractType === 'erc20') {
      hookExamples = this.generateERC20Hooks(contractName);
    }
    // For ERC-721 NFTs
    else if (contract.contractType === 'erc721') {
      hookExamples = this.generateERC721Hooks(contractName);
    }

    const content = `/**
 * ${contract.name} - Wagmi Hooks
 * Type: ${contract.contractType.toUpperCase()}
 *
 * Auto-generated by EitherWay
 */

import { useReadContract, useWriteContract, useWaitForTransactionReceipt } from 'wagmi';
import { ${contractName}ABI } from './${contractName}.abi';
import { ${contractName}Addresses, DEFAULT_${contractName.toUpperCase()}_CHAIN_ID } from './${contractName}.addresses';

const CONTRACT_ADDRESS = ${contractName}Addresses[DEFAULT_${contractName.toUpperCase()}_CHAIN_ID as keyof typeof ${contractName}Addresses];

${hookExamples}

/**
 * Generic read function hook
 */
export function use${contractName}Read<T = any>(
  functionName: string,
  args?: any[]
) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName,
    args: args || [],
  }) as { data: T; isLoading: boolean; error: Error | null };
}

/**
 * Generic write function hook
 */
export function use${contractName}Write() {
  const { data: hash, writeContract, isPending, error } = useWriteContract();

  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({
    hash,
  });

  const execute = (functionName: string, args?: any[]) => {
    writeContract({
      address: CONTRACT_ADDRESS,
      abi: ${contractName}ABI,
      functionName,
      args: args || [],
    });
  };

  return {
    execute,
    hash,
    isPending,
    isConfirming,
    isSuccess,
    error,
  };
}
`;

    return { filename, content };
  }

  /**
   * Generate ERC-20 specific hooks
   */
  private generateERC20Hooks(contractName: string): string {
    return `
/**
 * Get token name
 */
export function use${contractName}Name() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'name',
  });
}

/**
 * Get token symbol
 */
export function use${contractName}Symbol() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'symbol',
  });
}

/**
 * Get token balance for an address
 */
export function use${contractName}Balance(address?: string) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
  });
}

/**
 * Get total supply
 */
export function use${contractName}TotalSupply() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'totalSupply',
  });
}

/**
 * Transfer tokens
 */
export function use${contractName}Transfer() {
  const { data: hash, writeContract, isPending } = useWriteContract();

  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({
    hash,
  });

  const transfer = (to: string, amount: bigint) => {
    writeContract({
      address: CONTRACT_ADDRESS,
      abi: ${contractName}ABI,
      functionName: 'transfer',
      args: [to, amount],
    });
  };

  return {
    transfer,
    hash,
    isPending,
    isConfirming,
    isSuccess,
  };
}
`;
  }

  /**
   * Generate ERC-721 specific hooks
   */
  private generateERC721Hooks(contractName: string): string {
    return `
/**
 * Get NFT name
 */
export function use${contractName}Name() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'name',
  });
}

/**
 * Get NFT symbol
 */
export function use${contractName}Symbol() {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'symbol',
  });
}

/**
 * Get NFT balance for an address
 */
export function use${contractName}Balance(address?: string) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
  });
}

/**
 * Get owner of a specific token
 */
export function use${contractName}OwnerOf(tokenId?: bigint) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'ownerOf',
    args: tokenId !== undefined ? [tokenId] : undefined,
  });
}

/**
 * Get token URI
 */
export function use${contractName}TokenURI(tokenId?: bigint) {
  return useReadContract({
    address: CONTRACT_ADDRESS,
    abi: ${contractName}ABI,
    functionName: 'tokenURI',
    args: tokenId !== undefined ? [tokenId] : undefined,
  });
}

/**
 * Mint NFT
 */
export function use${contractName}Mint() {
  const { data: hash, writeContract, isPending } = useWriteContract();

  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({
    hash,
  });

  const mint = (to: string, uri: string) => {
    writeContract({
      address: CONTRACT_ADDRESS,
      abi: ${contractName}ABI,
      functionName: 'mint',
      args: [to, uri],
    });
  };

  return {
    mint,
    hash,
    isPending,
    isConfirming,
    isSuccess,
  };
}

/**
 * Transfer NFT
 */
export function use${contractName}Transfer() {
  const { data: hash, writeContract, isPending } = useWriteContract();

  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({
    hash,
  });

  const transfer = (from: string, to: string, tokenId: bigint) => {
    writeContract({
      address: CONTRACT_ADDRESS,
      abi: ${contractName}ABI,
      functionName: 'transferFrom',
      args: [from, to, tokenId],
    });
  };

  return {
    transfer,
    hash,
    isPending,
    isConfirming,
    isSuccess,
  };
}
`;
  }

  /**
   * Generate React component file
   * Example: MyTokenPanel.tsx
   */
  private generateComponentFile(contract: ContractInfo): { filename: string; content: string } {
    const contractName = this.toPascalCase(contract.name);
    const filename = `${contractName}Panel.tsx`;

    let componentContent = '';

    if (contract.contractType === 'erc20') {
      componentContent = this.generateERC20Component(contractName, contract.name);
    } else if (contract.contractType === 'erc721') {
      componentContent = this.generateERC721Component(contractName, contract.name);
    }

    return { filename, content: componentContent };
  }

  /**
   * Generate ERC-20 React component
   */
  private generateERC20Component(contractName: string, displayName: string): string {
    return `/**
 * ${displayName} - React Component
 * Type: ERC-20 Token
 *
 * Auto-generated by EitherWay
 */

import { useState } from 'react';
import { useAccount } from 'wagmi';
import { formatUnits, parseUnits } from 'viem';
import {
  use${contractName}Name,
  use${contractName}Symbol,
  use${contractName}Balance,
  use${contractName}TotalSupply,
  use${contractName}Transfer
} from './use${contractName}';

export function ${contractName}Panel() {
  const { address } = useAccount();
  const [transferTo, setTransferTo] = useState('');
  const [transferAmount, setTransferAmount] = useState('');

  // Read contract data
  const { data: name } = use${contractName}Name();
  const { data: symbol } = use${contractName}Symbol();
  const { data: balance } = use${contractName}Balance(address);
  const { data: totalSupply } = use${contractName}TotalSupply();

  // Write functions
  const { transfer, hash, isPending, isConfirming, isSuccess } = use${contractName}Transfer();

  const handleTransfer = () => {
    if (!transferTo || !transferAmount) return;

    try {
      const amount = parseUnits(transferAmount, 18); // Assuming 18 decimals
      transfer(transferTo, amount);
    } catch (error) {
      console.error('Transfer error:', error);
    }
  };

  return (
    <div className="contract-panel">
      <h2>${displayName}</h2>

      {/* Token Info */}
      <div className="token-info">
        <div className="info-item">
          <span>Name:</span>
          <span>{name || 'Loading...'}</span>
        </div>
        <div className="info-item">
          <span>Symbol:</span>
          <span>{symbol || 'Loading...'}</span>
        </div>
        <div className="info-item">
          <span>Your Balance:</span>
          <span>{balance ? formatUnits(balance as bigint, 18) : '0'} {symbol}</span>
        </div>
        <div className="info-item">
          <span>Total Supply:</span>
          <span>{totalSupply ? formatUnits(totalSupply as bigint, 18) : '0'} {symbol}</span>
        </div>
      </div>

      {/* Transfer Form */}
      {address && (
        <div className="transfer-section">
          <h3>Transfer Tokens</h3>
          <input
            type="text"
            placeholder="Recipient address (0x...)"
            value={transferTo}
            onChange={(e) => setTransferTo(e.target.value)}
            className="input-field"
          />
          <input
            type="text"
            placeholder="Amount"
            value={transferAmount}
            onChange={(e) => setTransferAmount(e.target.value)}
            className="input-field"
          />
          <button
            onClick={handleTransfer}
            disabled={isPending || isConfirming || !transferTo || !transferAmount}
            className="action-button"
          >
            {isPending || isConfirming ? 'Transferring...' : 'Transfer'}
          </button>

          {hash && (
            <div className="tx-status">
              <p>Transaction: {hash.slice(0, 10)}...{hash.slice(-8)}</p>
              {isSuccess && <p className="success">Transfer successful!</p>}
            </div>
          )}
        </div>
      )}

      {!address && (
        <p className="connect-prompt">Connect your wallet to interact with this token</p>
      )}

      <style jsx>{\`
        .contract-panel {
          padding: 24px;
          background: white;
          border-radius: 12px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .token-info {
          margin: 20px 0;
          padding: 16px;
          background: #f9fafb;
          border-radius: 8px;
        }

        .info-item {
          display: flex;
          justify-content: space-between;
          padding: 8px 0;
          border-bottom: 1px solid #e5e7eb;
        }

        .info-item:last-child {
          border-bottom: none;
        }

        .transfer-section {
          margin-top: 24px;
          padding: 16px;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
        }

        .input-field {
          width: 100%;
          padding: 10px;
          margin: 8px 0;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          font-size: 14px;
        }

        .action-button {
          width: 100%;
          padding: 12px;
          margin-top: 12px;
          background: #6366f1;
          color: white;
          border: none;
          border-radius: 6px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        }

        .action-button:hover:not(:disabled) {
          background: #4f46e5;
        }

        .action-button:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        .tx-status {
          margin-top: 12px;
          padding: 12px;
          background: #f3f4f6;
          border-radius: 6px;
          font-size: 13px;
        }

        .success {
          color: #059669;
          font-weight: 600;
        }

        .connect-prompt {
          text-align: center;
          padding: 24px;
          color: #6b7280;
        }
      \`}</style>
    </div>
  );
}
`;
  }

  /**
   * Generate ERC-721 React component
   */
  private generateERC721Component(contractName: string, displayName: string): string {
    return `/**
 * ${displayName} - React Component
 * Type: ERC-721 NFT
 *
 * Auto-generated by EitherWay
 */

import { useState } from 'react';
import { useAccount } from 'wagmi';
import {
  use${contractName}Name,
  use${contractName}Symbol,
  use${contractName}Balance,
  use${contractName}OwnerOf,
  use${contractName}TokenURI,
  use${contractName}Mint
} from './use${contractName}';

export function ${contractName}Panel() {
  const { address } = useAccount();
  const [mintTo, setMintTo] = useState(address || '');
  const [tokenURI, setTokenURI] = useState('');
  const [viewTokenId, setViewTokenId] = useState('');

  // Read contract data
  const { data: name } = use${contractName}Name();
  const { data: symbol } = use${contractName}Symbol();
  const { data: balance } = use${contractName}Balance(address);
  const { data: owner } = use${contractName}OwnerOf(viewTokenId ? BigInt(viewTokenId) : undefined);
  const { data: uri } = use${contractName}TokenURI(viewTokenId ? BigInt(viewTokenId) : undefined);

  // Write functions
  const { mint, hash, isPending, isConfirming, isSuccess } = use${contractName}Mint();

  const handleMint = () => {
    if (!mintTo || !tokenURI) return;
    mint(mintTo, tokenURI);
  };

  return (
    <div className="nft-panel">
      <h2>${displayName}</h2>

      {/* NFT Info */}
      <div className="nft-info">
        <div className="info-item">
          <span>Collection:</span>
          <span>{name || 'Loading...'}</span>
        </div>
        <div className="info-item">
          <span>Symbol:</span>
          <span>{symbol || 'Loading...'}</span>
        </div>
        {address && (
          <div className="info-item">
            <span>Your NFTs:</span>
            <span>{balance?.toString() || '0'}</span>
          </div>
        )}
      </div>

      {/* Mint Form */}
      {address && (
        <div className="mint-section">
          <h3>Mint NFT</h3>
          <input
            type="text"
            placeholder="Mint to address (0x...)"
            value={mintTo}
            onChange={(e) => setMintTo(e.target.value)}
            className="input-field"
          />
          <input
            type="text"
            placeholder="Token URI (ipfs://... or https://...)"
            value={tokenURI}
            onChange={(e) => setTokenURI(e.target.value)}
            className="input-field"
          />
          <button
            onClick={handleMint}
            disabled={isPending || isConfirming || !mintTo || !tokenURI}
            className="action-button"
          >
            {isPending || isConfirming ? 'Minting...' : 'Mint NFT'}
          </button>

          {hash && (
            <div className="tx-status">
              <p>Transaction: {hash.slice(0, 10)}...{hash.slice(-8)}</p>
              {isSuccess && <p className="success">NFT minted successfully!</p>}
            </div>
          )}
        </div>
      )}

      {/* View Token */}
      <div className="view-section">
        <h3>View Token</h3>
        <input
          type="text"
          placeholder="Token ID"
          value={viewTokenId}
          onChange={(e) => setViewTokenId(e.target.value)}
          className="input-field"
        />
        {viewTokenId && owner && (
          <div className="token-details">
            <p><strong>Owner:</strong> {owner as string}</p>
            {uri && <p><strong>URI:</strong> {uri as string}</p>}
          </div>
        )}
      </div>

      {!address && (
        <p className="connect-prompt">Connect your wallet to mint NFTs</p>
      )}

      <style jsx>{\`
        .nft-panel {
          padding: 24px;
          background: white;
          border-radius: 12px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .nft-info {
          margin: 20px 0;
          padding: 16px;
          background: #f9fafb;
          border-radius: 8px;
        }

        .info-item {
          display: flex;
          justify-content: space-between;
          padding: 8px 0;
          border-bottom: 1px solid #e5e7eb;
        }

        .info-item:last-child {
          border-bottom: none;
        }

        .mint-section, .view-section {
          margin-top: 24px;
          padding: 16px;
          border: 1px solid #e5e7eb;
          border-radius: 8px;
        }

        .input-field {
          width: 100%;
          padding: 10px;
          margin: 8px 0;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          font-size: 14px;
        }

        .action-button {
          width: 100%;
          padding: 12px;
          margin-top: 12px;
          background: #8b5cf6;
          color: white;
          border: none;
          border-radius: 6px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        }

        .action-button:hover:not(:disabled) {
          background: #7c3aed;
        }

        .action-button:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        .tx-status, .token-details {
          margin-top: 12px;
          padding: 12px;
          background: #f3f4f6;
          border-radius: 6px;
          font-size: 13px;
        }

        .success {
          color: #059669;
          font-weight: 600;
        }

        .connect-prompt {
          text-align: center;
          padding: 24px;
          color: #6b7280;
        }
      \`}</style>
    </div>
  );
}
`;
  }

  /**
   * Generate wagmi config file
   */
  private generateWagmiConfigFile(): { filename: string; content: string } {
    const filename = 'wagmi.config.ts';

    const content = `/**
 * Wagmi Configuration
 *
 * Auto-generated by EitherWay
 */

import { http, createConfig } from 'wagmi';
import { mainnet, sepolia, base, baseSepolia, arbitrum, arbitrumSepolia } from 'wagmi/chains';
import { injected, metaMask, safe, walletConnect } from 'wagmi/connectors';

const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID || 'YOUR_PROJECT_ID';

export const config = createConfig({
  chains: [mainnet, sepolia, base, baseSepolia, arbitrum, arbitrumSepolia],
  connectors: [
    injected(),
    metaMask(),
    safe(),
    walletConnect({ projectId }),
  ],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
    [base.id]: http(),
    [baseSepolia.id]: http(),
    [arbitrum.id]: http(),
    [arbitrumSepolia.id]: http(),
  },
});

declare module 'wagmi' {
  interface Register {
    config: typeof config;
  }
}
`;

    return { filename, content };
  }

  /**
   * Utility: Convert string to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]+(.)/g, (_, char) => char.toUpperCase())
      .replace(/^[a-z]/, (char) => char.toUpperCase());
  }
}
